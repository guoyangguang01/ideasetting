<application>
  <component name="AppStorage">
    <option name="newTranslationDialogCollapseDictViewer" value="false" />
    <option name="newTranslationDialogHeight" value="287" />
    <option name="newTranslationDialogWidth" value="594" />
    <option name="newTranslationDialogX" value="1043" />
    <option name="newTranslationDialogY" value="257" />
    <histories>
      <item value="To resolve this problem we are going to take into account two main requirements: vectors can't be null and the number of elements for vector have to be the same. Once we have added this guards throwing execptions we are going to implement this algorithm. To implement this scalar product we are going to iterate over v1 and v2 at the same time using a pointer defined with an integer named &quot;i&quot;. For every iteration we are going to accumulate the product of elements at position &quot;i&quot; for v1 and v2 inside an auxiliary variable named result. The complexity order of this algorithm in time terms is O(N) where N is the number of elements per vector. In space terms, the complexity order of this algorithm is O(1) because the auxiliary data structures used to implement this algorithm are not related to any problem parameter." />
      <item value="calculate Scalar Product" />
      <item value="local Time" />
      <item value="main" />
      <item value="args" />
      <item value="chronolo" />
      <item value="chronology" />
      <item value="Idempotency" />
      <item value="Cipher" />
      <item value="Driertor" />
      <item value="Gumball Machine" />
      <item value="Decoy Duck" />
      <item value="Beverage" />
      <item value="Waitress" />
      <item value="vegetarian" />
      <item value="Stereo" />
      <item value="Garage Door" />
      <item value="Ceiling Fan" />
      <item value="slot" />
      <item value="bubbling" />
      <item value="temperature" />
      <item value="Simulator" />
      <item value="Utile" />
      <item value="e Extract" />
      <item value="map Bulk" />
      <item value="tuple" />
      <item value="it's important to return the Jedis instance to the pool once you've finished using it" />
      <item value="unrecoverable" />
      <item value="deduce" />
      <item value="Basic algorithm is to loop trying to take either of two actions: 1. If queue apparently empty or holding same-mode nodes, try to add node to queue of waiters, wait to be fulfilled (or cancelled) and return matching item. 2. If queue apparently contains waiting items, and this call is of complementary mode, try to fulfill by CAS'ing item field of waiting node and dequeuing it, and then returning matching item. In each case, along the way, check for and try to help advance head and tail on behalf of other stalledslow threads. The loop starts off with a null check guarding against seeing uninitialized head or tail values. This never happens in current SynchronousQueue, but could if callers held non-volatilefinal ref to the transferer. The check is here anyway because it places null checks at top of loop, which is usually faster than having them implicitly interspersed." />
      <item value="Arithmetic Exception" />
      <item value="Thread Pool Executor" />
      <item value="Executor" />
      <item value="Blocking Queue" />
      <item value="Queue" />
      <item value="Synchronous Queue" />
      <item value="Strategy" />
      <item value="multicaster" />
      <item value="Scans the classpath for annotated components that will be auto-registered as Spring beans. By default, the Spring-provided @Component, @Repository, @Service, and @Controller stereotypes will be detected. Note: This tag implies the effects of the 'annotation-config' tag, activating @Required, @Autowired, @PostConstruct, @PreDestroy, @Resource, @PersistenceContext and @PersistenceUnit annotations in the component classes, which is usually desired for autodetected components (without external configuration). Turn off the 'annotation-config' attribute to deactivate this default behavior, for example in order to use custom BeanPostProcessor definitions for handling those annotations. Note: You may use placeholders in package paths, but only resolved against system properties (analogous to resource paths). A component scan results in new bean definition being registered; Spring's PropertyPlaceholderConfigurer will apply to those bean definitions just like to regular bean definitions, but it won't apply to the component scan settings themselves. See javadoc for org.springframework.context.annotation.ComponentScan for information on code-based alternatives to bootstrapping component-scanning." />
      <item value="Callback" />
      <item value="via" />
      <item value="collaborating" />
      <item value="equals Ignore Case" />
      <item value="Continuable" />
      <item value="concrete" />
      <item value="Indicates that the persistence provider must assign primary keys for the entity using a database identity column." />
      <item value="Plain Text" />
      <item value="Injector" />
      <item value="Decoy" />
      <item value="Mallard Duck" />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="129" />
        <entry key="ENGLISH" value="130" />
        <entry key="BASQUE" value="1" />
        <entry key="DANISH" value="1" />
        <entry key="GERMAN" value="1" />
        <entry key="DUTCH" value="1" />
        <entry key="SPANISH" value="2" />
        <entry key="ITALIAN" value="3" />
      </map>
    </option>
  </component>
  <component name="Cache">
    <option name="lastTrimTime" value="1652169379256" />
  </component>
  <component name="Settings">
    <option name="translateDocumentation" value="true" />
  </component>
</application>