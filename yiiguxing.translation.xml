<application>
  <component name="AppStorage">
    <option name="newTranslationDialogCollapseDictViewer" value="false" />
    <option name="newTranslationDialogHeight" value="287" />
    <option name="newTranslationDialogWidth" value="594" />
    <option name="newTranslationDialogX" value="1043" />
    <option name="newTranslationDialogY" value="257" />
    <histories>
      <item value="Reads the next line from the buffer and converts to a string array. The results are stored in peekedLines and peekedLine. Throws: IOException â€“ If bad things happen during the read" />
      <item value="variance" />
      <item value="Abstract Base Graph" />
      <item value="manually" />
      <item value="scratch" />
      <item value="GWT" />
      <item value="Gray" />
      <item value="Emergency" />
      <item value="DIESEL" />
      <item value="sequence of boards in a shortest solution; null if unsolvable" />
      <item value="jdbcTemplate.query(sql.toString(),param.toArray(), ParameterizedBeanPropertyRowMapper.newInstance(UserPointRecordStatistics.class))" />
      <item value="constraint" />
      <item value="perform independent trials on an n-by-n grid" />
      <item value="sample mean of percolation threshold" />
      <item value="sample standard deviation of percolation threshold" />
      <item value="G Locator" />
      <item value="queue" />
      <item value="To resolve this problem we are going to take into account two main requirements: vectors can't be null and the number of elements for vector have to be the same. Once we have added this guards throwing execptions we are going to implement this algorithm. To implement this scalar product we are going to iterate over v1 and v2 at the same time using a pointer defined with an integer named &quot;i&quot;. For every iteration we are going to accumulate the product of elements at position &quot;i&quot; for v1 and v2 inside an auxiliary variable named result. The complexity order of this algorithm in time terms is O(N) where N is the number of elements per vector. In space terms, the complexity order of this algorithm is O(1) because the auxiliary data structures used to implement this algorithm are not related to any problem parameter." />
      <item value="calculate Scalar Product" />
      <item value="local Time" />
      <item value="main" />
      <item value="args" />
      <item value="chronolo" />
      <item value="chronology" />
      <item value="Idempotency" />
      <item value="Cipher" />
      <item value="Driertor" />
      <item value="Gumball Machine" />
      <item value="Decoy Duck" />
      <item value="Beverage" />
      <item value="Waitress" />
      <item value="vegetarian" />
      <item value="Stereo" />
      <item value="Garage Door" />
      <item value="Ceiling Fan" />
      <item value="slot" />
      <item value="bubbling" />
      <item value="temperature" />
      <item value="Simulator" />
      <item value="Utile" />
      <item value="e Extract" />
      <item value="map Bulk" />
      <item value="tuple" />
      <item value="it's important to return the Jedis instance to the pool once you've finished using it" />
      <item value="unrecoverable" />
      <item value="deduce" />
      <item value="Basic algorithm is to loop trying to take either of two actions: 1. If queue apparently empty or holding same-mode nodes, try to add node to queue of waiters, wait to be fulfilled (or cancelled) and return matching item. 2. If queue apparently contains waiting items, and this call is of complementary mode, try to fulfill by CAS'ing item field of waiting node and dequeuing it, and then returning matching item. In each case, along the way, check for and try to help advance head and tail on behalf of other stalledslow threads. The loop starts off with a null check guarding against seeing uninitialized head or tail values. This never happens in current SynchronousQueue, but could if callers held non-volatilefinal ref to the transferer. The check is here anyway because it places null checks at top of loop, which is usually faster than having them implicitly interspersed." />
      <item value="Arithmetic Exception" />
      <item value="Thread Pool Executor" />
      <item value="Executor" />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="148" />
        <entry key="ENGLISH" value="149" />
        <entry key="BASQUE" value="1" />
        <entry key="DANISH" value="1" />
        <entry key="GERMAN" value="1" />
        <entry key="DUTCH" value="1" />
        <entry key="SPANISH" value="2" />
        <entry key="ITALIAN" value="3" />
      </map>
    </option>
  </component>
  <component name="Cache">
    <option name="lastTrimTime" value="1664159968256" />
  </component>
  <component name="Settings">
    <option name="translateDocumentation" value="true" />
    <option name="youdaoTranslateSettings">
      <youdao-translate>
        <option name="appId" value="313cb072b1d3c27f" />
      </youdao-translate>
    </option>
  </component>
  <component name="Translation.Cache">
    <option name="lastTrimTime" value="1693794962174" />
  </component>
  <component name="Translation.Settings">
    <option name="baiduTranslateSettings">
      <app-key>
        <option name="appId" value="20230709001738828" />
      </app-key>
    </option>
    <option name="primaryLanguage" value="CHINESE" />
    <option name="translateDocumentation" value="true" />
    <option name="translator" value="BAIDU" />
  </component>
  <component name="Translation.States">
    <histories>
      <item value="Candidate" />
      <item value="Exist" />
      <item value="chain" />
      <item value="Verify" />
      <item value="nside Once Per Request Filter originated by request" />
      <item value="Favicon" />
      <item value="injector" />
      <item value="Clamp zoom level, maintain auto-fit" />
      <item value="expected at least 1 bean which qualifies as autowire candidate" />
      <item value="The HttpServletRequest associated with the connection request received. Any parameters specified along with the connection request can be read from this object" />
      <item value="Called whenever the JavaScript Guacamole client makes a connection request via HTTP. It it up to the implementor of this function to define what conditions must be met for a tunnel to be configured and returned as a result of this connection request (whether some sort of credentials must be specified, for example" />
      <item value="This directory structure provides an example of how to apply custom branding and HTML extension to the Guacamole Client web application. This makes use of the guac-manifest.json file to specify the resources that are being provided, and provides examples of changing colors, fonts, and the login screen logo for the application. To use this, you need only to zip the file up into a JAR file, place it in the GUACAMOLE_HOMEextensions folder, and reload the web application. For example: zip -r tmpguacamole-branding-example.jar . mv tmpguacamole-branding-example.jar etcguacamoleextensions touch varlibtomcatwebappsguacamole.war These commands assume that your current working directory is this example directory, that your GUACAMOLE_HOME is located at etcguacamole, and that your the Guacamole Client web application is deployed in the varlibtomcatwebapps directory with the name &quot;guacamole.war&quot;. You should adjust the commands to fit your installation and environment" />
      <item value="tunnel" />
      <item value="Verify format using Apache RAT" />
      <item value="guacamole" />
      <item value="Seek in progress" />
      <item value="fake" />
      <item value="Nested" />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="18" />
        <entry key="ENGLISH" value="19" />
        <entry key="INDONESIAN" value="1" />
      </map>
    </option>
  </component>
</application>